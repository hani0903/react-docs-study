# Ref로 값 참조하기

-   `Ref`는 읽고 수정할 수 있는 `current` 프로퍼티를 가진 **일반 자바스크립트 객체**이다.
-   `Ref`는 React가 리렌더링하더라도 유지된다.
-   `Ref`는 변경되더라도 렌더링을 유발하지 않는다.

## 사용법

```jsx
import { useRef } from 'react';

function Component() {
    // ref 생성
    const ref = useRef(0);
}
```

## Ref와 State의 차이

### 반환 값

-   `useRef(initialValue)` 는 `{ current: initialValue }`를 반환한다.
-   `useState(initialValue)`는 State 변수의 현재 값과 Setter 함수 `[value, setValue]`를 반환한다.

### 렌더링

-   `useRef`로 반환된 객체 `{current: initialValue}`의 값을 바꿔도 리렌더링이 발생하지 않는다.
-   `state`값이 변경되면 리렌더링이 일어난다.

#### useRef 예시

```jsx
function RefExample() {
    const countRef = useRef(0);

    const handleClick = () => {
        // current 값을 직접 수정 - 리렌더링 안됨!
        countRef.current += 1;
        console.log('Ref count:', countRef.current); // 콘솔에는 증가된 값이 찍힘
    };

    console.log('컴포넌트 렌더링됨');

    return (
        <div>
            <p>Ref 카운트: {countRef.current}</p>
            <button onClick={handleClick}>Ref 증가</button>
        </div>
    );
}
```

#### useState 예시

```jsx
function StateExample() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        // setState 함수로만 수정 가능 - 리렌더링됨!
        setCount(count + 1);
        console.log('State count:', count); // 아직 이전 값이 찍힘
    };

    console.log('컴포넌트 렌더링됨');

    return (
        <div>
            <p>State 카운트: {count}</p>
            <button onClick={handleClick}>State 증가</button>
        </div>
    );
}
```

### Mutable vs Immutable

#### useRef는 Mutable

```jsx
function RefExample() {
    const countRef = useRef(0);

    const handleClick = () => {
        // 직접 값을 바꿀 수 있음
        countRef.current = 100;
        countRef.current += 50;
        countRef.current = countRef.current * 2;
    };

    return <button onClick={handleClick}>Ref 수정</button>;
}
```

-   `useRef`는 직접 반환값을 수정해도 된다.

#### useState는 Immutable

```jsx
function StateExample() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        // ❌
        // count = 100; // 에러

        // 반드시 setter 함수로만 변경해야 함
        setCount(100);
    };

    return <button onClick={handleClick}>State 수정</button>;
}
```

### 렌더링 중 규칙

#### useRef : 렌더링 중에는 읽거나 쓰면 안됨

```jsx
function BadRefExample() {
    const countRef = useRef(0);

    // ❌ 렌더링 중에 ref 값을 읽거나 쓰면 안됨
    countRef.current += 1; // 문제 발생 가능
    console.log(countRef.current); // 예측 불가능한 결과

    return <div>{countRef.current}</div>; // 이것도 불가능함
}
```

-   렌더링에 사용해야 한다면 `state`변수를 사용할 것

#### useState - 언제든 읽을 수 있음

```jsx
function StateExample() {
    const [count, setCount] = useState(0);

    // ⭕ 렌더링 중에 state 읽기는 가능함
    console.log('현재 count:', count);

    const isEven = count % 2 === 0; // ⭕ 계산에도 사용할 수 있음

    return (
        <div>
            <p>카운트: {count}</p> {/* 읽기도 가능함 ⭕ */}
            <p>{isEven ? '짝수' : '홀수'}</p>
            <button onClick={() => setCount(count + 1)}>증가</button>
        </div>
    );
}
```

-   state변수는 렌더링 중에는 항상 같은 값임이 보장됨
-   따라서 예측이 가능함

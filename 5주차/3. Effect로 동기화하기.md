# Effect로 동기화하기

## 컴포넌트 내 로직의 3가지 유형

React 컴포넌트에는 서로 다른 목적을 가진 세 가지 로직이 있다.

### 1. 렌더링 코드 (순수 계산)

```jsx
function UserProfile({ user }) {
    // 이 부분이 렌더링 코드
    const content = <p>{user.comment}</p>;
    const userName = user.firstName + ' ' + user.lastName;

    return (
        <div>
            <h1>{userName}</h1>
            {content}
        </div>
    );
}
```

-   입력이 같으면 항상 같은 결과를 반환한다
-   UI가 어떻게 보일지만 계산한다
-   부수 효과는 포함하면 안 된다

### 2. 이벤트 핸들러 (사용자 상호작용)

```jsx
function Card() {
    function handleOnClick() {
        console.log('버튼 클릭됨');
    }

    return (
        <div>
            <button onClick={handleOnClick}>버튼</button>
        </div>
    );
}
```

-   사용자의 특정 행동에 응답하는 형태이다
-   상호 작용에 따른 변화를 처리한다
-   부수 효과를 유발해도 괜찮다

### 3. Effect (렌더링 자체에 의한 동기화)

렌더링이나 이벤트 핸들러로 처리할 수 없는 **외부 시스템과의 동기화**, **데이터 패칭** 등의 부수 효과를 처리한다.

```jsx
// 타이머 설정
useEffect(() => {
    const timer = setInterval(() => {
        console.log('1초마다 실행');
    }, 1000);

    return () => clearInterval(timer);
}, []);

// 브라우저 API 사용
useEffect(() => {
    document.title = `현재 사용자: ${userName}`;
}, [userName]);
```

#### Effect vs 이벤트 핸들러

| 구분      | Effect               | 이벤트 핸들러        |
| --------- | -------------------- | -------------------- |
| 실행 시점 | 렌더링 후 자동       | 사용자 액션 시       |
| 실행 조건 | 의존성 배열 변경 시  | 특정 이벤트 발생 시  |
| 목적      | 외부 시스템과 동기화 | 사용자 상호작용 처리 |

## Effect 작성 방법 (3단계)

### 1단계: Effect 선언하기

```jsx
import { useEffect } from 'react';

function MyComponent() {
    useEffect(() => {
        // 이곳의 코드는 *모든* 렌더링 후에 실행됩니다
    });
    return <div />;
}
```

-   컴포넌트 최상위 레벨에서 `useEffect` 호출
-   `useEffect`는 화면에 렌더링이 반영될 때까지 코드 실행을 "지연"시킨다

#### 실제 예제: 비디오 플레이어

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
    const ref = useRef(null);

    useEffect(() => {
        if (isPlaying) {
            ref.current.play();
        } else {
            ref.current.pause();
        }
    }, [isPlaying]);

    return <video ref={ref} src={src} loop playsInline />;
}
```

-   `ref.current.play()`는 DOM 조작이므로 렌더링 코드에 넣으면 안 됨
-   `useEffect`로 감싸면 브라우저 미디어 API와 React 상태를 동기화할 수 있음

### 2단계: Effect의 의존성 지정하기

```jsx
useEffect(() => {
    // 모든 렌더링 후에 실행된다.
});

useEffect(() => {
    // 마운트될 때만 실행된다. (컴포넌트가 나타날 때)
}, []);

useEffect(() => {
    // 마운트될 때 실행되며, a 또는 b 중 하나라도 변경된 경우에도 실행된다.
}, [a, b]);
```

-   의존성 배열에는 여러 개의 종속성을 포함할 수 있다
-   React는 지정한 모든 종속성이 이전 렌더링과 동일한 값인 경우에만 Effect를 다시 실행하지 않는다
-   의존성은 직접 "선택"할 수 없다 - Effect 내부의 코드를 기반으로 React가 기대하는 의존성과 일치하지 않으면 린트 에러 발생

### 3단계: 필요 시 클린업 함수 추가하기

클린업 함수는 **컴포넌트가 마운트 해제될 때** 및 **Effect가 다시 실행되기 전마다** 호출된다.

```jsx
useEffect(() => {
    const connection = createConnection();
    connection.connect();

    return () => {
        connection.disconnect(); // 클린업 함수
    };
}, []);
```

#### 클린업 함수가 필요한 경우

##### (1) 외부 API 또는 라이브러리 사용

**같은 동작을 두 번 해도 괜찮은 경우 → 클린업 불필요**

```jsx
useEffect(() => {
    const map = mapRef.current;
    map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

**같은 동작을 두 번 하면 문제가 되는 경우 → 클린업 필요**

```jsx
useEffect(() => {
    const dialog = dialogRef.current;
    dialog.showModal();
    return () => dialog.close(); // 클린업 함수로 원래 상태로 되돌리기
}, []);
```

##### (2) 이벤트 구독하기

```jsx
useEffect(() => {
    function handleScroll(e) {
        console.log(window.scrollX, window.scrollY);
    }
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

##### (3) 애니메이션 트리거

```jsx
useEffect(() => {
    const node = ref.current;
    node.style.opacity = 1; // 애니메이션 트리거
    return () => {
        node.style.opacity = 0; // 초기값으로 리셋
    };
}, []);
```

##### (4) 데이터 패칭 (경쟁 상태 방지)

```jsx
useEffect(() => {
    let ignore = false; // 클로저 변수

    async function startFetching() {
        const json = await fetchTodos(userId);
        if (!ignore) {
            // 아직 유효한 요청인지 확인
            setTodos(json);
        }
    }

    startFetching();

    return () => {
        ignore = true; // 클린업에서 무효화
    };
}, [userId]);
```

**문제 상황:**

1. userId = 'Alice'로 API 요청 시작 (느린 응답)
2. 사용자가 빠르게 userId = 'Bob'으로 변경
3. userId = 'Bob'으로 API 요청 시작 (빠른 응답)
4. Bob 데이터가 먼저 도착 → setTodos(bobData)
5. Alice 데이터가 나중에 도착 → setTodos(aliceData) 😱

**해결:** `ignore` 플래그로 오래된 응답을 무시

## 각 렌더링마다 고유한 Effect

Effect는 각 렌더링에 속한 고유한 스냅샷이다. 각 Effect는 해당 렌더링의 props와 state를 클로저로 "기억"한다.

```jsx
// 첫 번째 렌더링 (roomId = "general")
useEffect(() => {
    const connection = createConnection('general'); // 'general'이 클로저에 캡처됨
    connection.connect();
    return () => connection.disconnect();
}, ['general']);

// 세 번째 렌더링 (roomId = "travel")
useEffect(() => {
    const connection = createConnection('travel'); // 'travel'이 클로저에 캡처됨
    connection.connect();
    return () => connection.disconnect();
}, ['travel']);
```

**실행 순서:**

1. **이전 Effect 정리**: 첫 번째 렌더링의 cleanup 함수 실행
2. **새로운 Effect 실행**: 세 번째 렌더링의 Effect 실행

## 개발 환경에서의 특별한 동작

### Strict Mode의 이중 마운트

```jsx
// 개발 환경에서 실행 순서:
// 1. 컴포넌트 마운트 → Effect 실행
// 2. 즉시 언마운트 → Cleanup 실행
// 3. 다시 마운트 → Effect 재실행
```

**목적:**

-   Cleanup이 제대로 구현되었는지 확인
-   메모리 누수나 경쟁 상태 버그를 조기 발견

### Hot Reload 시 재마운트

파일 저장 시마다 기존 Effect cleanup 실행 후 새로운 Effect 실행

## Effect가 아닌 경우들

### 애플리케이션 초기화

```jsx
// 컴포넌트 외부에 배치
if (typeof window !== 'undefined') {
    checkAuthToken();
    loadDataFromLocalStorage();
}

function App() {
    // ...
}
```

### 특정 이벤트에 의한 작업 (예: 제품 구매)

```jsx
// ❌ 잘못된 방법
useEffect(() => {
    fetch('/api/buy', { method: 'POST' });
}, []);

// ✅ 올바른 방법
function handleClick() {
    fetch('/api/buy', { method: 'POST' });
}
```

구매는 렌더링이 아닌 특정 상호작용(버튼 클릭)에 의해 발생해야 한다.

## 핵심 정리

-   **Effect는 특정 상호작용이 아닌 렌더링 자체에 의해 발생**
-   **외부 시스템과의 동기화**가 주요 목적
-   **의존성은 Effect 내부 코드에 의해 결정**되며 직접 선택할 수 없음
-   **각 렌더링마다 고유한 Effect**를 가지며 클로저로 값을 캡처
-   **Strict Mode는 버그 조기 발견**을 위해 Effect를 두 번 실행
-   **클린업 함수는 정리 작업**을 위해 Effect 재실행 전과 언마운트 시 호출

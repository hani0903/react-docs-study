# Effect가 필요하지 않은 경우

## 불필요한 state + Effect 제거하기

기존 props나 state에서 계산할 수 있다면 `state` 변수와 `useEffect`를 통한 업데이트를 제거하고, **렌더링 중에 계산**하는 것이 좋다.

### ❌ 잘못된 방법

```jsx
function Form() {
    const [firstName, setFirstName] = useState('Taylor');
    const [lastName, setLastName] = useState('Swift');

    // 🔴 중복된 state 및 불필요한 Effect
    const [fullName, setFullName] = useState('');
    useEffect(() => {
        setFullName(firstName + ' ' + lastName);
    }, [firstName, lastName]);
    // ...
}
```

**문제점:**

-   불필요한 state 변수 (`fullName`)
-   매번 2번의 렌더링 발생 (state 업데이트 → Effect 실행)
-   코드 복잡성 증가

### ⭕ 올바른 방법

```jsx
function Form() {
    const [firstName, setFirstName] = useState('Taylor');
    const [lastName, setLastName] = useState('Swift');

    // ✅ 기존 state로부터 렌더링 중에 계산됨
    const fullName = firstName + ' ' + lastName;
    // ...
}
```

**장점:**

-   1번의 렌더링으로 처리
-   동기화 문제 없음
-   코드 간소화

## 비용이 많이 드는 계산 캐싱하기

`newTodo`가 변경될 때마다 `todos`와 `filter`는 변하지 않았는데도 불필요한 `getFilteredTodos(todos, filter)` 계산이 반복되는 문제를 해결해야 한다.

### ❌ 잘못된 방법

```jsx
// 매번 다시 계산됨
const visibleTodos = getFilteredTodos(todos, filter);

// 또는 Effect 사용 (더 나쁨)
const [visibleTodos, setVisibleTodos] = useState([]);
useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
}, [todos, filter]);
```

### ⭕ 올바른 방법: useMemo 사용

```jsx
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
    const [newTodo, setNewTodo] = useState('');

    // ✅ todos나 filter가 변경될 때만 다시 계산
    const visibleTodos = useMemo(() => {
        return getFilteredTodos(todos, filter);
    }, [todos, filter]); // 의존성 배열

    return (
        <div>
            <input value={newTodo} onChange={(e) => setNewTodo(e.target.value)} />
            {/* todos 표시 */}
        </div>
    );
}
```

**useMemo 동작 방식:**

-   첫 번째 렌더링: 함수 실행하고 결과 저장
-   재렌더링 시: 의존성 비교 후 변경된 경우에만 재실행
-   변경되지 않은 경우: 저장된 결과 반환

## prop 변경 시 모든 state 초기화하기

`ProfilePage`는 `userId` prop을 받고 해당 유저의 프로필을 보여준다. 다른 유저의 프로필로 이동할 때 기존 `comment`를 초기화해야 한다.

### ❌ 잘못된 방법

```jsx
export default function ProfilePage({ userId }) {
    const [comment, setComment] = useState('');

    // 🔴 피하세요: Effect에서 prop 변경 시 state 초기화
    useEffect(() => {
        setComment('');
    }, [userId]);
    // ...
}
```

**문제점:**

-   2번 렌더링 (오래된 값 → 초기화된 값)
-   깜빡임 현상 발생

### ⭕ 올바른 방법: key 사용

```jsx
export default function ProfilePage({ userId }) {
    return <Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
    // ⭕ key 변경 시 모든 state가 자동으로 재설정됨
    const [comment, setComment] = useState('');
    // ...
}
```

**key 동작 방식:**

1. `userId`가 변경되면 `key`도 변경됨
2. React가 완전히 새로운 컴포넌트로 인식
3. 이전 컴포넌트 삭제 후 새 컴포넌트 생성
4. 모든 state가 초기값으로 재설정

## prop 변경 시 일부 state만 조정하기

prop 변경 시 전체가 아닌 일부 state만 재설정/조정하고 싶은 경우에는 **렌더링 중에 직접 state를 조정**하는 것이 좋다.

### ❌ 잘못된 방법

```jsx
function List({ items }) {
    const [isReverse, setIsReverse] = useState(false);
    const [selection, setSelection] = useState(null);

    // 🔴 피하세요: Effect에서 prop 변경 시 state 조정하기
    useEffect(() => {
        setSelection(null);
    }, [items]);
    // ...
}
```

### ⭕ 올바른 방법 1: 렌더링 중 state 조정

```jsx
function List({ items }) {
    const [isReverse, setIsReverse] = useState(false);
    const [selection, setSelection] = useState(null);

    // ✅ 렌더링 중 state 조정
    const [prevItems, setPrevItems] = useState(items);
    if (items !== prevItems) {
        setPrevItems(items);
        setSelection(null);
    }
    // ...
}
```

**동작 원리:**

-   `items` 변경 감지 시 즉시 state 업데이트
-   React가 JSX를 버리고 즉시 재렌더링

### ⭕ 올바른 방법 2: 계산된 값 사용 (더 권장)

```jsx
function List({ items }) {
    const [isReverse, setIsReverse] = useState(false);
    const [selectedId, setSelectedId] = useState(null);

    // 🟢 최고: 렌더링 중에 모든 것을 계산
    const selection = items.find((item) => item.id === selectedId) ?? null;
    // ...
}
```

**장점:**

-   더 간단하고 명확한 로직
-   items가 변경되어도 selectedId가 유효하지 않으면 자동으로 null

## 이벤트 핸들러 간 로직 공유하기

**장바구니 추가** 버튼과 **바로 구매** 버튼 클릭 시 "장바구니에 추가되었습니다!" 알림을 보여주는 경우, 공통 로직을 별도 함수로 분리해야 한다.

### ❌ 잘못된 방법

```jsx
function ProductPage({ product, addToCart }) {
    // 🔴 문제가 있는 방식: Effect 사용
    useEffect(() => {
        if (product.isInCart) {
            showNotification(`Added ${product.name} to the shopping cart!`);
        }
    }, [product]);

    function handleBuyClick() {
        addToCart(product);
    }

    function handleCheckoutClick() {
        addToCart(product);
        navigateTo('/checkout');
    }
    // ...
}
```

**문제점:**

-   페이지 새로고침 시 불필요한 알림
-   다른 이유로 product가 변경될 때도 알림
-   브라우저 뒤로가기 시에도 알림

### ⭕ 올바른 방법

```jsx
function ProductPage({ product, addToCart }) {
    // 🟢 올바른 방식: 공통 로직을 함수로 분리
    function buyProduct() {
        addToCart(product);
        showNotification(`Added ${product.name} to the shopping cart!`);
    }

    function handleBuyClick() {
        buyProduct(); // 공통 함수 호출
    }

    function handleCheckoutClick() {
        buyProduct(); // 공통 함수 호출
        navigateTo('/checkout');
    }
    // ...
}
```

**판단 기준:**

| 실행 이유                           | 사용할 곳     | 예시                                |
| ----------------------------------- | ------------- | ----------------------------------- |
| **컴포넌트가 화면에 나타나서**      | Effect        | 데이터 로딩, 구독 시작, 타이머 설정 |
| **사용자가 특정 동작을 해서**       | 이벤트 핸들러 | 버튼 클릭, 폼 제출, 드래그앤드롭    |
| **특정 값이 변경되어서**            | Effect        | 제목 업데이트, 캐시 무효화          |
| **사용자가 의도적으로 시작한 작업** | 이벤트 핸들러 | 파일 업로드, 결제 처리              |

## POST 요청 보내기

POST 요청을 보낼 때 **실행 이유**를 명확히 분석해야 한다.

### ❌ 잘못된 방법

```jsx
function Form() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');

    // 🟢 이건 괜찮음: 페이지 방문 분석
    useEffect(() => {
        post('/analytics/event', { eventName: 'visit_form' });
    }, []);

    // 🔴 문제가 있는 부분: 회원가입을 Effect로 처리
    const [jsonToSubmit, setJsonToSubmit] = useState(null);
    useEffect(() => {
        if (jsonToSubmit !== null) {
            post('/api/register', jsonToSubmit);
        }
    }, [jsonToSubmit]);

    function handleSubmit(e) {
        e.preventDefault();
        setJsonToSubmit({ firstName, lastName }); // state 설정만 함
    }
    // ...
}
```

**문제점:**

-   3단계 처리 과정 (handleSubmit → state 변경 → Effect 실행)
-   예상치 못한 동작 가능성
-   디버깅 어려움

### ⭕ 올바른 방법

```jsx
function Form() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    // 🟢 올바른 Effect: 페이지 방문 분석
    // - 사용자가 "페이지를 봤기 때문에" 실행
    useEffect(() => {
        post('/analytics/event', { eventName: 'visit_form' });
    }, []);

    // 🟢 올바른 이벤트 핸들러: 사용자 액션에 직접 반응
    // - 사용자가 "버튼을 눌렀기 때문에" 실행
    async function handleSubmit(e) {
        e.preventDefault();

        if (isSubmitting) return; // 중복 제출 방지

        setIsSubmitting(true);

        try {
            await post('/api/register', { firstName, lastName });
            alert('회원가입이 완료되었습니다!');
            setFirstName('');
            setLastName('');
        } catch (error) {
            alert('회원가입 중 오류가 발생했습니다: ' + error.message);
        } finally {
            setIsSubmitting(false);
        }
    }
    // ...
}
```

## 연쇄 계산 피하기

다음 규칙을 가진 카드 게임에서 **Effect 체인**으로 접근하는 것은 옳지 않다.

> **게임 규칙:**
>
> 1. 카드를 한 장씩 뽑아서 놓는다
> 2. 골드 카드를 4장 모으면 다음 라운드로 진행
> 3. 5라운드를 완료하면 게임 끝
> 4. 게임이 끝나면 축하 메시지 표시

### ❌ 잘못된 방법: Effect 체인

```jsx
function Game() {
    const [card, setCard] = useState(null);
    const [goldCardCount, setGoldCardCount] = useState(0);
    const [round, setRound] = useState(1);
    const [isGameOver, setIsGameOver] = useState(false);

    // 🔴 문제: Effect들이 서로를 트리거하는 체인 구조
    useEffect(() => {
        if (card !== null && card.gold) {
            setGoldCardCount((c) => c + 1);
        }
    }, [card]);

    useEffect(() => {
        if (goldCardCount > 3) {
            setRound((r) => r + 1);
            setGoldCardCount(0);
        }
    }, [goldCardCount]);

    useEffect(() => {
        if (round > 5) {
            setIsGameOver(true);
        }
    }, [round]);

    useEffect(() => {
        if (isGameOver) {
            alert('Good game!');
        }
    }, [isGameOver]);

    function handlePlaceCard(nextCard) {
        if (isGameOver) throw Error('Game already ended.');
        setCard(nextCard); // 이것이 체인 반응의 시작점
    }
    // ...
}
```

**문제점:**

-   한 번의 액션으로 최대 4번의 렌더링 발생
-   복잡한 디버깅
-   예측하기 어려운 동작

### ⭕ 올바른 방법: 이벤트 핸들러에서 통합 처리

```jsx
function Game() {
    const [card, setCard] = useState(null);
    const [goldCardCount, setGoldCardCount] = useState(0);
    const [round, setRound] = useState(1);

    // 🟢 계산 가능한 값은 state가 아닌 변수로
    const isGameOver = round > 5;

    function handlePlaceCard(nextCard) {
        if (isGameOver) throw Error('Game already ended.');

        // 🟢 모든 state 변경을 한 번에 계산
        setCard(nextCard);

        if (nextCard.gold) {
            const newGoldCount = goldCardCount + 1;

            if (newGoldCount > 3) {
                // 라운드 완료 처리
                const newRound = round + 1;

                setGoldCardCount(0);
                setRound(newRound);

                // 게임 종료 체크 (계산된 값 사용)
                if (newRound > 5) {
                    alert('Good game!');
                }
            } else {
                // 단순히 골드 카드 개수만 증가
                setGoldCardCount(newGoldCount);
            }
        }
    }
    // ...
}
```

**장점:**

-   단 1번의 렌더링으로 모든 처리 완료
-   명확하고 예측 가능한 로직
-   쉬운 디버깅

## 핵심 정리

### Effect를 사용해야 하는 경우

-   **컴포넌트가 나타났기 때문에** 실행되어야 하는 로직
-   **외부 시스템과의 동기화** (API, 브라우저 API, 서드파티 라이브러리)
-   **값의 변경에 따른 자동 업데이트**

### 이벤트 핸들러를 사용해야 하는 경우

-   **사용자의 특정 행동** 때문에 실행되어야 하는 로직
-   **의도적인 사용자 상호작용** (클릭, 제출, 드래그 등)
-   **일회성 작업** (알림 표시, 페이지 이동, 데이터 전송)

### 로직 공유 방법

1. **공통 함수 분리** - 가장 간단하고 직관적
2. **커스텀 Hook** - 복잡한 로직이나 재사용이 많은 경우
3. **유틸리티 함수** - 컴포넌트와 무관한 순수한 로직

### 🎯 황금 원칙

**"왜 이 코드가 실행되어야 하는가?"를 항상 자문하자!**

-   컴포넌트가 보여서 → Effect
-   사용자가 액션해서 → 이벤트 핸들러
-   계산 가능한 값 → 변수나 useMemo
-   모든 state 초기화 → key 사용
-   일부 state 조정 → 렌더링 중 처리 또는 계산된 값

# React Effect의 생명주기

effect는 **동기화 시작**과 **동기화를 중지**하는 두 가지 작업을 할 수 있다.

## effect vs 컴포넌트

-   **컴포넌트의 생명주기:** 마운트 → 업데이트 → 언마운트
-   **Effect의 생명주기:** 동기화 시작 → 동기화 중지

> effect의 생명주기는 컴포넌트의 생명주기와 독립적이기 때문에 **Effect의 관점**으로 생각해야 한다.

```jsx
// ❌ 컴포넌트의 관점으로 생각하기
'마운트될 때 연결하고, 언마운트될 때 해제한다';

// ✅ Effect의 관점으로 생각하기
'roomId와 동기화를 시작하고, 필요 시 중지한다';
```

## 기본 패턴

공식문서의 예시인 채팅방 연결을 보자.

```jsx
function ChatRoom({ roomId }) {
    useEffect(() => {
        // 동기화 시작
        const connection = createConnection(serverUrl, roomId);
        connection.connect();

        // 동기화 중지 방법 정의
        return () => connection.disconnect();
    }, [roomId]); // roomId가 변경되면 재동기화

    return <h1>Welcome to {roomId}!</h1>;
}
```

-   `roomId="general"` → general 방 연결
-   `roomId="travel"`로 변경 → general 연결 해제 → travel 연결
-   컴포넌트 언마운트 -> travel 연결 해제

## 재동기화가 필요한 이유

의존성 배열에 들어가 있는 변수들의 값과 실제 연결이 다르게 되면 **UI**와 **외부 시스템**이 불일치하게 된다.

## 반응형 값

반응형 값이란 **컴포넌트 내부에서 선언되고 렌더링 중에 계산되어 시간에 따라 변할 수 있는 값**을 말한다.

```jsx
function ChatRoom({ roomId, selectedServerUrl }) {
    const settings = useContext(SettingsContext); // 반응형
    const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // 반응형

    useEffect(() => {
        const connection = createConnection(serverUrl, roomId);
        connection.connect();
        return () => connection.disconnect();
    }, [roomId, serverUrl]); // 모든 반응형 값을 의존성에 포함시켜야 함
}
```

### 반응형 값 식별하기

컴포넌트 내부의 모든 값은 반응형 값이다.

```jsx
const serverUrl = 'https://localhost:1234'; // ❌ 반응형이 아닌 값

function Component(props) {
    // ✅ 반응형 값들
    const [state, setState] = useState(); // state
    const { prop1, prop2 } = props; // props
    const calculated = prop1 + prop2; // 계산된 값
    const contextValue = useContext(MyContext); // context

    // ❌ 반응형이 아닌 값들
    const constantValue = 'hello'; // 상수
    let mutableValue = window.location.pathname; // 변경 가능한 외부 값 → 반응형 값이 아님 (React가 변경을 감지 못함)
    const ref = useRef(); // ref 객체 자체는 반응형이지만, ref.current는 반응형이 아님
}
```

## 의존성 배열

의존성 배열에는 useEffect 내부 로직에서 쓰이는 모든 반응형 값이 포함되어 있어야 한다.

### 모든 반응형 값 포함하기

```jsx
function MyComponent({ userId, filter }) {
    const [data, setData] = useState([]);
    const processedData = data.filter((item) => item.type === filter);

    useEffect(() => {
        fetchUserData(userId, filter).then(setData);
    }, [userId, filter]); // ✅ 모든 반응형 값 포함
}
```

### 빈 의존성 배열

만약 의존성을 갖는 반응형 값이 없다면, `[]`만 적어줘도 된다.

```jsx
// 반응형 값을 사용하지 않는 경우
const serverUrl = 'https://api.example.com'; // 컴포넌트 외부
const roomId = 'general'; // 컴포넌트 외부

function ChatRoom() {
    useEffect(() => {
        const connection = createConnection(serverUrl, roomId);
        connection.connect();
        return () => connection.disconnect();
    }, []); // ✅ 반응형 값이 없으므로 빈 배열
}
```

### 반응형 값을 비반응형으로 만들기

반응형 값을 비반응형으로 바꿔주면 의존성 배열에서 제거할 수 있다.

```jsx
// ❌ 잘못된 방법: 린터 무시
useEffect(() => {
    doSomething(userId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);

// ✅ 올바른 방법 ➀: 컴포넌트 외부로 이동
const userId = 'fixed-user-id';

// ✅ 올바른 방법 ➁: Effect 내부로 이동
useEffect(() => {
    const userId = 'fixed-user-id';
    doSomething(userId);
}, []);
```

## Effect 내부의 독립적인 동기화 프로세스 분리하기

관련없는 동기화 프로세스는 여러 개의 Effect로 분리하는게 좋다.

```jsx
// ❌ 관련 없는 로직을 하나의 Effect에
useEffect(() => {
    logVisit(roomId); // 방문 로그
    const connection = createConnection(roomId);
    connection.connect(); // 채팅 연결
    return () => connection.disconnect();
}, [roomId]);

// ✅ 별도의 Effect로 분리
useEffect(() => {
    logVisit(roomId); // 방문 로그는 별도 프로세스
}, [roomId]);

useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect(); // 채팅 연결은 별도 프로세스
    return () => connection.disconnect();
}, [roomId]);
```

## 요약

Effect를 작성할 때는 다음 내용을 체크해보자

1.  Effect가 정말 필요할까?

    -   외부 시스템과 동기화가 필요한지
    -   트리거가 무엇인지 (사용자 이벤트 or 자동 실행)

2.  의존성은 잘 설정돼 있나?

    -   내부 로직에서 사용되는 모든 반응형 값이 포함되어 있는지
    -   불필요한 의존성은 없는지

3.  cleanup이 필요할까?

    -   구독 해제가 필요한지
    -   진행 중인 작업 취소가 필요한지

4.  독립적인 프로세스인가?

    -   해당 effect가 다른 동기화 로직과 분리되어 있는지
    -   하나의 책임만을 갖고 있는지

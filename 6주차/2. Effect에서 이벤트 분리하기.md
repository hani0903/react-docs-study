# Effect에서 이벤트 분리하기

## 이벤트 핸들러와 Effect 중에 선택하는 방법

**코드가 실행되어야 하는 이유**를 따져보면 해당 코드를 이벤트 핸들러 함수에 넣어야 할지, Effect에 넣어야 할지 알 수 있다.

### 이벤트 핸들러

이벤트 핸들러는 **특정 상호작용**에 대한 **응답**으로 실행된다.

-   (ex) 채팅방에서 **전송 버튼이 클릭**되는 경우, 전송 로직이 실행되어야 한다.
    -   따라서 이 경우 이벤트 핸들러에 전송 로직을 포함해야 한다.

```jsx
function ChatRoom({ roomId }) {
    const [message, setMessage] = useState('');
    // ...
    function handleSendClick() {
        sendMessage(message);
    }
    // ...
    return (
        <>
            <input value={message} onChange={(e) => setMessage(e.target.value)} />
            <button onClick={handleSendClick}>전송</button>
        </>
    );
}
```

### Effect

effect에는 동기화가 필요할 때마다 실행된다. 또한 사용자의 특정 행동에 의해 실행되는 코드가 아니다.

-   (ex) 채팅방 컴포넌트는 렌더링 될 때 채팅방과 연결되어야 한다.
    -   채팅방 ID가 달라지면 재동기화되어야 한다.

```jsx
function ChatRoom({ roomId }) {
    // ...
    useEffect(() => {
        const connection = createConnection(serverUrl, roomId);
        connection.connect();
        return () => {
            connection.disconnect();
        };
    }, [roomId]);
    // ...
}
```

## 반응형 값과 반응형 로직

반응형 값은 데이터 렌더링 과정에 관여하는 값이며, 리렌더링으로 인해 변경될 수 있는 값이다.

-   (ex) `message`를 편집 / 드롭다운에서 `roomId`를 다른 거로 변경

이벤트 핸들러와 Effect는 각각 반응형 값에 다르게 반응한다.

### 이벤트 핸들러

이벤트 핸들러 내부의 로직은 반응형이 아니고, 사용자가 같은 상호작용을 반복해야 재실행되는 로직이다.

```jsx
function handleSendClick() {
    sendMessage(message);
}
```

-   `message`를 전송하는 로직은 사용자가 특정 버튼을 눌렀을 때 실행되어야 한다 → 이벤트 핸들러!

> -   변화에 반응하지 않는다.
> -   반응형 값을 읽을 수 있다.

### Effect

Effect 내부의 로직은 반응형이다. 반응형 값을 읽고, 그 값을 의존성으로 지정해야 한다. 리렌더링을 통해 반응형 값이 변경되면 Effect 내부의 로직이 재실행된다.

```jsx
useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
        connection.disconnect();
    };
}, [roomId]);
```

-   사용자가 `roomId`를 바꾸는 건, 다른 채팅방에 연결하고 싶다는 의미이다.
-   따라서 방에 연결하는 로직은 `roomId`에 반응하는 로직이어야 한다.

## Effect에서 비반응형 로직을 추출하는 방법

Effect에서 사용하는 반응형 값이지만, 로직 자체는 비반응형 로직인 경우, `useEffectEvent`라는 특수한 훅을 사용할 수 있다.

> 공식문서를 보면 개발 중인 실험적인 API라고 함

### 문제가 있는 코드

```jsx
function ChatRoom({ roomId, theme }) {
    useEffect(() => {
        const connection = createConnection(serverUrl, roomId);
        connection.on('connected', () => {
            showNotification('연결됨!', theme);
        });
        connection.connect();
        return () => {
            connection.disconnect();
        };
    }, [roomId, theme]); // ✅ 모든 의존성 선언됨
    // ...
}
```

-   `theme`을 변경할 때에도 채팅방 연결이 새로 되고, '연결됨!' 토스트가 뜬다.
-   `theme` 은 채팅방 연결과는 전혀 관련없는 반응형 값이다.

### 해결한 코드

```jsx
const onConnected = useEffectEvent(() => {
    showNotification('연결됨!', theme);
});

useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
        onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
}, [roomId]); // ✅ 모든 의존성이 선언됨
```

-   위 코드에서 `onConnected`를 **Effect 이벤트**라고 한다.
-   이벤트 핸들러와 유사하게 동작한다.
-   내부 로직은 비반응형이고 props와 state는 항상 최신값임이 보장된다.

## Effect 이벤트의 한계

Effect 이벤트는 사용할 수 있는 방법이 매우 제한적이다.

-   Effect 내부에서만 호출해야 한다.
-   다른 컴포넌트나 Hook에 전달하면 안된다.

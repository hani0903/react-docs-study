# Effect의 의존성 제거하기

의존성은 선택하는게 아니라 **Effect 내부의 코드에 의해 자동으로 결정**된다.

> Effect의 코드 내부에서 사용되는 **모든 반응형 값**은 의존성 목록에 포함되어야 한다.

## 의존성 변경 프로세스

> **1. 코드 먼저 변경:** Effect 내부의 코드나 반응형 값의 선언 방식을 수정한다.
> **2. 의존성 조정:** 변경된 코드에 맞춰 의존성 배열을 업데이트한다.
> **3. 의존성 조정:** 의존성 목록이 만족스럽지 않다면 1단계로 돌아가 코드를 다시 수정한다.

## 의존성 린터 억제의 위험성

린터가 의존성 목록에 포함될거라 예측하는 값들은 실제로 포함되어야 하는 값들이다. 따라서 다음과 같이 의존성 린터를 억제하면 버그가 발생할 확률이 높다.

```jsx
useEffect(() => {
    // ...
    // 🔴 Avoid suppressing the linter like this:
    // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

### 실제 버그 사례

```jsx
export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
    setCount(count + increment); // 클로저로 인한 stale closure 문제가 발생함
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  ...
  return<div>{count}</div>
}
```

**문제점**

-   첫 렌더링 시 `onTick`은 `count = 0`, `increment = 1`을 캡처한다.
    -   따라서 `setCount(0 + 1)`을 실행하는 함수이다.
-   이후 렌더링에서 `onClick` 핸들러는 새로 생성되지만, Effect는 새로 생성된 함수가 아닌 초기 함수를 계속 참조한다.
-   결과적으로 `count`값은 1에서 변하지 않는다.

## 불필요한 의존성 제거 전략

### Effect 내부에서 State 업데이트하기

#### 문제가 있는 코드

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]); // ✅ All dependencies declared
  // ...
```

Effect 내부에서 `roomId`와 `messages`를 사용하기 때문에 의존성 배열에는 반드시 두 반응형 값이 포함되어야 한다.

> **문제점⚠️**
>
> `message`가 의존성에 포함되면서 새 메세지가 전송될 때마다 채팅이 다시 연결되는 문제가 발생!

#### 업데이터 함수를 통해 해결

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

**업데이터 함수**를 setter 함수에 전달함으로써 이 문제를 해결할 수 있다.

### Props로 객체를 받는 방법

#### 문제 상황

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // ✅ All dependencies declared
  // ...
```

```jsx
<ChatRoom
    roomId={roomId}
    options={{
        serverUrl: serverUrl,
        roomId: roomId,
    }}
/>
```

부모 컴포넌트가 객체를 생성한 뒤, 그 객체를 props로 자식에게 넘겨주는 경우가 있다. 이 때 만약 부모가 렌더링 중에 객체를 생성한다면, 이 값을 자식에서 바로 사용하는 건 좋지 않다.

> 내용은 같아도 참조가 다르기 때문에 리렌더링할 때마다 Effect가 재연결될 수가 있다.

React는 `Object.is()`를 사용해서 의존성을 비교하는데, **객체 비교**와 **원시값 비교**에서 다음과 같은 차이를 갖는다.

##### 객체

```jsx
// 렌더링 1
const options1 = { serverUrl: 'localhost', roomId: 'general' };

// 렌더링 2 (내용은 같지만 새로운 객체)
const options2 = { serverUrl: 'localhost', roomId: 'general' };

Object.is(options1, options2); // false → Effect 재실행!
```

##### 원시값

```jsx
// 렌더링 1
const roomId1 = 'general';
const serverUrl1 = 'localhost';

// 렌더링 2
const roomId2 = 'general';
const serverUrl2 = 'localhost';

Object.is(roomId1, roomId2); // true
Object.is(serverUrl1, serverUrl2); // true
// → Effect 재실행 안됨!
```

#### 해결 방법

```jsx
function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // ...
```

-   이렇게 하면 참조가 아닌 각 값 자체를 비교하게 되므로 부모가 리렌더링 될 때마다 Effect가 실행되는 걸 방지할 수 있다.

### 객체와 함수 의존성 문제 해결

함수에서도 객체와 동일하게 참조를 비교하게 된다.

```jsx
// 매번 새로운 함수가 생성됨
const func1 = () => {
    return 'hello';
};
const func2 = () => {
    return 'hello';
};

console.log(func1 === func2); // false - 내용이 같아도 참조가 다름
```

#### 문제 상황

```jsx
<ChatRoom
    roomId={roomId}
    getOptions={() => {
        return {
            serverUrl: serverUrl,
            roomId: roomId,
        };
    }}
/>
```

따라서 부모가 리렌더링될 때마다 함수가 새로 생성된다.

#### 해결 방법1

```jsx
function ChatRoom({ getOptions }) {
    const [message, setMessage] = useState('');

    // ✅ 렌더링 시점에 함수를 호출해서 값 추출
    const { roomId, serverUrl } = getOptions();

    useEffect(() => {
        const connection = createConnection({
            roomId, // 원시값
            serverUrl, // 원시값
        });
        connection.connect();
        return () => connection.disconnect();
    }, [roomId, serverUrl]); // ✅ 함수가 아닌 원시값을 의존성으로 사용
}
```

부모가 전달한 함수를 **Effect 외부에서 호출**히면 해결할 수 있다.

> 단, 해당 함수가 **순수 함수**여야 하고, 렌더링 중 호출해도 안전해야 한다!

#### 해결 방법2

또는 부모 컴포넌트에서 함수를 생성할 때 `useCallback`훅을 사용해 생성하고 자식에게 전달해주는 방법도 있다.

```jsx
function ParentComponent() {
    const [roomId, setRoomId] = useState('general');
    const [serverUrl, setServerUrl] = useState('https://localhost:1234');

    // ✅ useCallback으로 함수 메모이제이션
    const getOptions = useCallback(() => {
        return {
            serverUrl: serverUrl,
            roomId: roomId,
        };
    }, [serverUrl, roomId]); // 실제 의존하는 값들만 포함

    return <ChatRoom getOptions={getOptions} />;
}
```

> 이 경우 함수가 순수하지 않아도 사용 가능하며, 부모 컴포넌트에서 자식 컴포넌트 제어가 가능해진다는 장점을 갖는다.

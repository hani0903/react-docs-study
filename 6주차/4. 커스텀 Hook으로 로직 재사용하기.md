# 커스텀 Hook으로 로직 재사용하기

React는 `useState`, `useEffect` 같은 내장 Hook 외에도, 특정한 목적을 가진 **커스텀 Hook**을 만들 수 있다. 커스텀 Hook을 통해 컴포넌트 간에 로직을 재사용하고 코드를 더 깔끔하게 관리할 수 있다.

> **대표적인 커스텀 Hook 예시:**
>
> -   데이터 페칭 훅 (`useApi`, `useQuery`)
> -   사용자 온라인 상태 확인 훅 (`useOnlineStatus`)
> -   채팅방 연결 훅 (`useChatRoom`)
> -   로컬스토리지 관리 훅 (`useLocalStorage`)

---

## 커스텀 Hook 기본 개념

### 커스텀 Hook이란?

커스텀 Hook은 **`use`로 시작하는 함수**로, 내부에서 다른 Hook들을 사용할 수 있다. 여러 컴포넌트에서 공통으로 사용되는 로직을 하나의 함수로 분리하여 재사용성을 높인다.

### 네이밍 규칙

-   **반드시 `use`로 시작**해야 한다. (`useOnlineStatus`, `useData` 등)
-   React가 Hook 규칙을 적용할 수 있도록 도움
-   `use`를 붙임으로써 함수 내부에 React Hook이 포함되어 있음을 명시적으로 표현할 수 있다.

```jsx
// ✅ 올바른 네이밍
function useOnlineStatus() {
    /* ... */
}
function useUserData(id) {
    /* ... */
}

// ❌ 잘못된 네이밍
function onlineStatus() {
    /* Hook 규칙 적용 안됨 */
}
function getUserData(id) {
    /* Hook이 아닌 일반 함수처럼 보임 */
}
```

---

## 커스텀 Hook 작성 예제

### 기본 예제: 온라인 상태 확인

```jsx
function useOnlineStatus() {
    // navigator.onLine으로 실제 초기값 설정
    const [isOnline, setIsOnline] = useState(navigator.onLine);

    useEffect(() => {
        function handleOnline() {
            setIsOnline(true);
        }

        function handleOffline() {
            setIsOnline(false);
        }

        // 브라우저 이벤트 리스너 등록
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        // 클린업 함수로 이벤트 리스너 제거
        return () => {
            window.removeEventListener('online', handleOnline);
            window.removeEventListener('offline', handleOffline);
        };
    }, []); // 마운트 시에만 실행

    return isOnline;
}
```

### 컴포넌트에서 사용하기

```jsx
function StatusBar() {
    const isOnline = useOnlineStatus();
    return <h1>{isOnline ? '✅ 온라인' : '❌ 연결 안 됨'}</h1>;
}

function SaveButton() {
    const isOnline = useOnlineStatus();

    function handleSaveClick() {
        console.log('✅ 진행사항 저장됨');
    }

    return (
        <button disabled={!isOnline} onClick={handleSaveClick}>
            {isOnline ? '진행사항 저장' : '재연결 중...'}
        </button>
    );
}
```

**핵심 포인트:** `StatusBar`와 `SaveButton`은 같은 `useOnlineStatus` 훅을 사용하지만, **완전히 독립적인 상태**를 가진다. 각각 별도의 `useState`와 `useEffect`를 실행한다.

---

## 커스텀 Hook의 동작 원리

### 상태 공유 vs 로직 공유

```jsx
// 두 컴포넌트는 같은 훅을 사용
function ComponentA() {
    const isOnline = useOnlineStatus(); // 독립적인 상태 A
    // ...
}

function ComponentB() {
    const isOnline = useOnlineStatus(); // 독립적인 상태 B
    // ...
}
```

> **커스텀 Hook은**
>
> -   **로직을 공유**한다
> -   **상태 자체를 공유하지 않는다** (각각 독립적인 `useState`)

> **상태를 공유하고 싶다면** Context API나 상태 관리 라이브러리를 사용해야 한다.

### 리렌더링과의 관계

커스텀 Hook 내부의 코드는 **컴포넌트가 리렌더링될 때마다 다시 실행**된다. 이는 일반 함수와 동일한 동작이다.

---

## 실용적인 커스텀 Hook 예제

### 데이터 페칭 Hook

기존의 반복적인 데이터 페칭 로직을 개선해보자.

#### 개선 전: 반복되는 코드

```jsx
function ShippingForm({ country }) {
    const [cities, setCities] = useState(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        let ignore = false;
        setLoading(true);

        fetch(`/api/cities?country=${country}`)
            .then((response) => response.json())
            .then((json) => {
                if (!ignore) {
                    setCities(json);
                    setLoading(false);
                }
            });
        return () => {
            ignore = true;
        };
    }, [country]);

    // city 데이터도 비슷한 패턴으로 반복...
}
```

#### 개선 후: 커스텀 Hook 활용

```jsx
function useData(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);

    useEffect(() => {
        if (!url) {
            setData(null);
            return;
        }

        let ignore = false;
        setLoading(true);
        setError(null);

        fetch(url)
            .then((response) => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then((json) => {
                if (!ignore) {
                    setData(json);
                }
            })
            .catch((err) => {
                if (!ignore) {
                    setError(err.message);
                }
            })
            .finally(() => {
                if (!ignore) {
                    setLoading(false);
                }
            });

        return () => {
            ignore = true;
        };
    }, [url]);

    return { data, loading, error };
}
```

#### 개선 후 컴포넌트 코드

```jsx
function ShippingForm({ country }) {
    const [city, setCity] = useState(null);

    const { data: cities, loading: citiesLoading, error: citiesError } = useData(`/api/cities?country=${country}`);

    const { data: areas, loading: areasLoading } = useData(city ? `/api/areas?city=${city}` : null);

    if (citiesLoading) return <div>도시 목록 로딩중...</div>;
    if (citiesError) return <div>에러: {citiesError}</div>;

    return (
        <form>
            <select onChange={(e) => setCity(e.target.value)}>
                <option value="">도시 선택</option>
                {cities?.map((city) => (
                    <option key={city.id} value={city.id}>
                        {city.name}
                    </option>
                ))}
            </select>

            {city && (
                <select disabled={areasLoading}>
                    <option value="">구역 선택</option>
                    {areas?.map((area) => (
                        <option key={area.id} value={area.id}>
                            {area.name}
                        </option>
                    ))}
                </select>
            )}
        </form>
    );
}
```

---

## 언제 커스텀 Hook을 만들어야 할까?

### 커스텀 Hook을 만들어야 하는 경우

1. **Effect 로직이 반복될 때**

    ```jsx
    useEffect(() => {
        // API 호출, 이벤트 리스너 등록, 타이머 설정...
    }, [dependencies]);
    ```

2. **외부 시스템과 동기화가 필요할 때**

    - API 호출, WebSocket 연결
    - DOM 조작, 브라우저 API 사용
    - 써드파티 라이브러리 연동

3. **복잡한 상태 로직이 재사용될 때**
    - 폼 검증, 페이지네이션
    - 캐싱, 에러 핸들링

### ❌ 커스텀 Hook이 불필요한 경우

```jsx
// ❌ 단순한 useState 래핑은 의미없음
function useFormInput(initialValue) {
    const [value, setValue] = useState(initialValue);
    return [value, setValue];
}

// ✅ 그냥 직접 사용하는 게 나음
function LoginForm() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    // ...
}
```

---

## 커스텀 Hook 네이밍 가이드

커스텀 Hook 이름은 **목적과 사용법을 명확히** 전달하도록 지어야 한다.

### 기본 원칙

```jsx
// ✅ 명확하고 구체적
useOnlineStatus(); // 온라인 상태 확인
useLocalStorage(key); // 로컬스토리지 관리
useDebounce(value, delay); // 디바운스 적용

// ❌ 모호하고 추상적
useHelper(); // 무엇을 도와주는지 불분명
useManager(); // 무엇을 관리하는지 불분명
useUtil(); // 너무 포괄적
```

### 외부 시스템 연동 시

기술적이고 구체적인 용어를 사용한다.

```jsx
useMediaQuery(query); // CSS 미디어 쿼리
useIntersectionObserver(ref, options); // Intersection Observer API
useGeolocation(); // Geolocation API
useWebSocket(url); // WebSocket 연결
```

### 매개변수와 반환값이 명확히 드러나는 이름

```jsx
// ✅ 사용법을 유추할 수 있음
const user = useUser(userId);
const { data, loading } = useApi(endpoint);
const [value, setValue] = useLocalStorage('key', defaultValue);

// ❌ 사용법이 불분명
const result = useData();
const output = useProcess(input);
```

# useState

React에서 **컴포넌트에 상태(state)를 추가**할 수 있게 해주는 가장 기본적이고 중요한 Hook이다. 함수형 컴포넌트에서 동적인 값을 관리하고, 값이 변경될 때 컴포넌트를 다시 렌더링시킨다.

```jsx
import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>현재 카운트: {count}</p>
            <button onClick={() => setCount(count + 1)}>증가</button>
        </div>
    );
}
```

---

## 기본 사용법

### 컴포넌트에 state 추가하기

```jsx
import { useState } from 'react';

function MyComponent() {
    // 구문: const [상태변수, 설정함수] = useState(초기값);
    const [age, setAge] = useState(28);
    const [name, setName] = useState('Taylor');
    const [todos, setTodos] = useState([]);

    return (
        <div>
            <p>
                이름: {name}, 나이: {age}
            </p>
            <button onClick={() => setAge(age + 1)}>나이 증가</button>
        </div>
    );
}
```

### 호출 위치 규칙

-   **컴포넌트의 최상위 레벨**에서만 호출 가능
-   **커스텀 Hook 내부**에서도 호출 가능
-   조건문, 반복문, 중첩 함수 내부에서는 호출 불가

```jsx
function MyComponent() {
    // ✅ 올바른 위치
    const [count, setCount] = useState(0);

    if (count > 5) {
        // ❌ 조건문 내부에서 Hook 호출 불가
        const [error, setError] = useState('');
    }

    return <div>{count}</div>;
}
```

---

## 매개변수와 반환값

### 매개변수: 초기 상태값

```jsx
// 1. 직접 값 전달
const [name, setName] = useState('초기 이름');
const [count, setCount] = useState(0);
const [isVisible, setIsVisible] = useState(true);

// 2. 초기화 함수 전달 (지연 초기화)
const [todos, setTodos] = useState(() => {
    const savedTodos = localStorage.getItem('todos');
    return savedTodos ? JSON.parse(savedTodos) : [];
});
```

**초기화 함수의 특징:**

-   초기 렌더링에서만 실행됨
-   순수 함수여야 함 (같은 입력에 항상 같은 출력)
-   인수를 받지 않아야 함
-   값을 반드시 반환해야 함

### 반환값: [상태, 상태 설정 함수]

```jsx
const [current, setCurrent] = useState(initial);
```

1. **current**: 현재 상태값 (첫 렌더링에서는 초기값과 동일)
2. **setCurrent**: 상태를 업데이트하는 함수

---

## 상태 업데이트 방법

### 1. 직접 값 설정

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    const handleIncrement = () => {
        setCount(count + 1); // 현재 값 + 1
    };

    return <button onClick={handleIncrement}>카운트: {count}</button>;
}
```

### 2. 업데이터 함수 사용

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    const handleIncrement = () => {
        // 이전 상태를 기반으로 새 상태 계산
        setCount((prevCount) => prevCount + 1);
    };

    // 여러 번 호출할 때 유용
    const handleIncrementThree = () => {
        setCount((prev) => prev + 1); // 1
        setCount((prev) => prev + 1); // 2
        setCount((prev) => prev + 1); // 3
    };

    return (
        <div>
            <button onClick={handleIncrement}>+1</button>
            <button onClick={handleIncrementThree}>+3</button>
            <p>카운트: {count}</p>
        </div>
    );
}
```

**언제 업데이터 함수를 사용할까?**

-   이전 상태에 기반해서 새 상태를 계산할 때
-   같은 이벤트에서 여러 번 상태를 업데이트할 때
-   콜백 함수 내에서 최신 상태를 보장하고 싶을 때

---

## 객체와 배열 상태 관리

### 객체 상태 업데이트

```jsx
function UserProfile() {
    const [user, setUser] = useState({
        name: 'John',
        age: 25,
        email: 'john@example.com',
    });

    const updateName = (newName) => {
        // ❌ 직접 수정 (불변성 위반)
        user.name = newName;
        setUser(user);

        // ✅ 새 객체 생성 (불변성 유지)
        setUser({
            ...user,
            name: newName,
        });

        // ✅ 업데이터 함수 사용
        setUser((prevUser) => ({
            ...prevUser,
            name: newName,
        }));
    };

    return (
        <div>
            <p>
                {user.name} ({user.age}세)
            </p>
            <button onClick={() => updateName('Jane')}>이름 변경</button>
        </div>
    );
}
```

### 배열 상태 업데이트

```jsx
function TodoList() {
    const [todos, setTodos] = useState([]);

    const addTodo = (text) => {
        // ✅ 새 배열 생성
        setTodos([...todos, { id: Date.now(), text, completed: false }]);
    };

    const removeTodo = (id) => {
        // ✅ 필터링으로 새 배열 생성
        setTodos(todos.filter((todo) => todo.id !== id));
    };

    const toggleTodo = (id) => {
        // ✅ map으로 새 배열 생성
        setTodos(todos.map((todo) => (todo.id === id ? { ...todo, completed: !todo.completed } : todo)));
    };

    return (
        <div>
            {todos.map((todo) => (
                <div key={todo.id}>
                    <span
                        style={{
                            textDecoration: todo.completed ? 'line-through' : 'none',
                        }}
                    >
                        {todo.text}
                    </span>
                    <button onClick={() => toggleTodo(todo.id)}>완료</button>
                    <button onClick={() => removeTodo(todo.id)}>삭제</button>
                </div>
            ))}
            <button onClick={() => addTodo('새 할일')}>할일 추가</button>
        </div>
    );
}
```

---

## 주의사항과 흔한 실수

### 1. 상태 업데이트는 비동기적

```jsx
function Counter() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
        setCount(count + 1);
        console.log(count); // ❌ 아직 이전 값! (0이 출력됨)

        // ✅ 업데이트된 값을 즉시 사용하려면
        const newCount = count + 1;
        setCount(newCount);
        console.log(newCount); // ✅ 새 값 (1이 출력됨)
    };

    return <button onClick={handleClick}>카운트: {count}</button>;
}
```

### 2. 객체/배열 직접 수정 금지

```jsx
function BadExample() {
    const [items, setItems] = useState(['apple', 'banana']);

    const addItem = () => {
        // ❌ 기존 배열을 직접 수정
        items.push('orange');
        setItems(items); // React가 업데이트를 무시함. 리렌더링 발생 ❌

        // ✅ 새 배열 생성
        setItems([...items, 'orange']);
    };
}
```

### 3. 조건부 Hook 호출 금지

```jsx
function ConditionalHooks({ condition }) {
    // ❌ 조건부로 Hook 호출
    if (condition) {
        const [state, setState] = useState(0);
    }

    // ✅ 항상 같은 순서로 Hook 호출
    const [state, setState] = useState(condition ? 0 : null);
}
```

-   리액트는 Hook 호출 순서를 기억함

---

## 실무 활용 패턴

### 1. 폼 상태 관리

```jsx
function ContactForm() {
    const [formData, setFormData] = useState({
        name: '',
        email: '',
        message: '',
    });

    const [errors, setErrors] = useState({});
    const [isSubmitting, setIsSubmitting] = useState(false);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData((prev) => ({
            ...prev,
            [name]: value,
        }));

        // 에러 상태 초기화
        if (errors[name]) {
            setErrors((prev) => ({
                ...prev,
                [name]: '',
            }));
        }
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);

        try {
            await submitForm(formData);
            setFormData({ name: '', email: '', message: '' });
        } catch (error) {
            setErrors({ submit: error.message });
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <input name="name" value={formData.name} onChange={handleChange} placeholder="이름" />
            <input name="email" value={formData.email} onChange={handleChange} placeholder="이메일" />
            <textarea name="message" value={formData.message} onChange={handleChange} placeholder="메시지" />
            <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? '전송 중...' : '전송'}
            </button>
        </form>
    );
}
```

### 2. 리스트 아이템 관리

```jsx
function ShoppingCart() {
    const [cart, setCart] = useState([]);

    const addToCart = (product) => {
        setCart((prev) => {
            const existingItem = prev.find((item) => item.id === product.id);

            if (existingItem) {
                // 기존 아이템의 수량 증가
                return prev.map((item) => (item.id === product.id ? { ...item, quantity: item.quantity + 1 } : item));
            } else {
                // 새 아이템 추가
                return [...prev, { ...product, quantity: 1 }];
            }
        });
    };

    const removeFromCart = (productId) => {
        setCart((prev) => prev.filter((item) => item.id !== productId));
    };

    const updateQuantity = (productId, newQuantity) => {
        if (newQuantity <= 0) {
            removeFromCart(productId);
            return;
        }

        setCart((prev) => prev.map((item) => (item.id === productId ? { ...item, quantity: newQuantity } : item)));
    };

    const getTotalPrice = () => {
        return cart.reduce((total, item) => total + item.price * item.quantity, 0);
    };

    return (
        <div>
            <h2>장바구니 (총 {getTotalPrice()}원)</h2>
            {cart.map((item) => (
                <div key={item.id}>
                    <span>
                        {item.name} x {item.quantity}
                    </span>
                    <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>+</button>
                    <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>-</button>
                    <button onClick={() => removeFromCart(item.id)}>삭제</button>
                </div>
            ))}
        </div>
    );
}
```

### 3. 컴포넌트 간 상태 공유 (상태 호이스팅)

```jsx
function App() {
    const [user, setUser] = useState(null);
    const [theme, setTheme] = useState('light');

    return (
        <div className={`app theme-${theme}`}>
            <Header user={user} theme={theme} onThemeChange={setTheme} />
            <Main user={user} />
            <Footer />
        </div>
    );
}

function Header({ user, theme, onThemeChange }) {
    return (
        <header>
            <h1>My App</h1>
            {user ? <span>안녕하세요, {user.name}님!</span> : <span>로그인이 필요합니다</span>}
            <button onClick={() => onThemeChange(theme === 'light' ? 'dark' : 'light')}>
                {theme === 'light' ? '🌙' : '☀️'} 테마 변경
            </button>
        </header>
    );
}
```

---

## key를 사용한 상태 초기화

동일한 컴포넌트에서 상태를 완전히 초기화하고 싶을 때 `key` prop을 활용할 수 있다.

```jsx
function UserProfile({ userId }) {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        setIsLoading(true);
        fetchUser(userId).then((userData) => {
            setUser(userData);
            setIsLoading(false);
        });
    }, [userId]);

    if (isLoading) return <div>로딩 중...</div>;

    return <div>사용자: {user?.name}</div>;
}

// 사용하는 곳에서
function App() {
    const [currentUserId, setCurrentUserId] = useState(1);

    return (
        <div>
            {/* key가 변경되면 컴포넌트가 완전히 새로 마운트됨 */}
            <UserProfile key={currentUserId} userId={currentUserId} />
            <button onClick={() => setCurrentUserId((prev) => prev + 1)}>다음 사용자</button>
        </div>
    );
}
```

---

## 성능 최적화 팁

### 1. 지연 초기화 사용

```jsx
// ❌ 매번 복잡한 계산 실행
const [state, setState] = useState(expensiveCalculation());

// ✅ 초기 렌더링에서만 실행
const [state, setState] = useState(expensiveCalculation);
```

### 2. 객체/배열 참조 최적화

```jsx
// ❌ 매번 새 객체 생성으로 인한 불필요한 리렌더링
const [config, setConfig] = useState({});

const updateTheme = (newTheme) => {
    // 🚨 문제: 값이 같아도 항상 새 객체를 만들어서 setState 호출
    setConfig((prev) => ({
        ...prev,
        theme: newTheme,
    }));
};
```

-   `newTheme`이 기존값과 같은지 확인을 안하고 새 객체를 생성해서 `setState`를 호출한다.
-   새 객체를 생성했기 때문에 참조가 달라졌고 리렌더링이 발생한다.

```jsx
// ✅ 실제 변경이 있을 때만 새 객체 생성
const updateConfig = useCallback((key, value) => {
    setConfig((prev) => {
        if (prev[key] === value) return prev; // 같은 값이면 업데이트 하지 않음
        return { ...prev, [key]: value };
    });
}, []);
```

-   값이 같으면 기존 객체를 그대로 반환한다.

> 사용자가 같은 버튼을 여러 번 클릭할 수 있는 상황, 복잡한 객체 상태를 관리하는 상황에서 위와 같은 `if`분기를 통해 리렌더링을 방지할 수 있다.
